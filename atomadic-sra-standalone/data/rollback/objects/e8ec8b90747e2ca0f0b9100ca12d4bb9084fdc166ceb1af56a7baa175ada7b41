
import time
import json

class DynamicOutputPanel:
    """
    Dynamic Output & UX Panel
    Relevance filtering, formatting, archiving, and UX optimization.
    Formats all SRA outputs for optimal readability.
    """
    def __init__(self):
        self.archive = []
        self.format_config = {
            "use_markdown": True,
            "max_width": 120,
            "show_timestamps": True,
            "show_metrics": True
        }

    def format_output(self, content, output_type="general"):
        """Format content for display based on type."""
        formatted = ""
        
        if output_type == "code":
            formatted = f"```python\n{content}\n```"
        elif output_type == "table":
            formatted = self._format_table(content)
        elif output_type == "alert":
            formatted = f"âš  **Alert**: {content}"
        elif output_type == "metric":
            formatted = self._format_metrics(content)
        else:
            formatted = f"**SRA Output**:\n{content}"
        
        if self.format_config["show_timestamps"]:
            formatted = f"[{time.strftime('%H:%M:%S')}] {formatted}"
        
        self.archive.append({
            "content": content[:500],
            "type": output_type,
            "timestamp": time.strftime("%Y-%m-%dT%H:%M:%S")
        })
        
        return formatted

    def _format_table(self, data):
        """Format dict/list as aligned table."""
        if isinstance(data, dict):
            max_key = max(len(str(k)) for k in data.keys()) if data else 0
            lines = []
            for k, v in data.items():
                lines.append(f"  {str(k).ljust(max_key)} â”‚ {v}")
            header = f"  {'Key'.ljust(max_key)} â”‚ Value"
            separator = f"  {'â”€' * max_key}â”€â”¼â”€{'â”€' * 40}"
            return "\n".join([header, separator] + lines)
        elif isinstance(data, list) and data:
            if isinstance(data[0], dict):
                keys = list(data[0].keys())
                header = " | ".join(keys)
                rows = [" | ".join(str(row.get(k, "")) for k in keys) for row in data]
                return header + "\n" + "-" * len(header) + "\n" + "\n".join(rows)
        return str(data)

    def _format_metrics(self, metrics):
        """Format metrics with visual indicators."""
        lines = ["ðŸ“Š **Metrics**:"]
        if isinstance(metrics, dict):
            for k, v in metrics.items():
                if isinstance(v, float):
                    bar_len = int(v * 20) if v <= 1 else int(min(v, 100) / 5)
                    bar = "â–ˆ" * bar_len + "â–‘" * (20 - bar_len)
                    lines.append(f"  {k}: [{bar}] {v}")
                else:
                    lines.append(f"  {k}: {v}")
        return "\n".join(lines)

    def filter_relevance(self, items, query, threshold=0.3):
        """Filter items by relevance to query."""
        query_words = set(query.lower().split())
        results = []
        for item in items:
            text = str(item).lower()
            matches = sum(1 for w in query_words if w in text)
            score = matches / len(query_words) if query_words else 0
            if score >= threshold:
                results.append({"item": item, "relevance": round(score, 2)})
        return sorted(results, key=lambda x: x["relevance"], reverse=True)

    def get_archive(self):
        return self.archive
